Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]

Solution:

备注，这个题目本身不算很难，但是边界的检测方面比较tricky，我开始的时候大意了，是看了test case失败的时候才发现哪里出了问题，呵呵。

首先，感觉我们可以用递归来做，每一层递归就是做一圈，分为向右向下向左向上，这样就是一圈。然后只要记录圈数就可以了。

在一开始的时候，在绕一圈的时候，使用了左闭右开的方式，就是向右的时候，从零开始，最后剩下一个。然后向下，也是从零开始，最后剩下一个。然后向左，也是从tail开始往左，到1结束。然后是向上，从最后一行开始，向上，还是剩下最后一个。这样四个方向都跑完一圈，就是一个loop 然后我们loop count ++, 再继续做下一轮。

注意，when lc is a int in [0, 1,2,...]，说明我们已经跑完了lc圈，那么再下一次做的时候，我们的开始位置其实是 (lc, lc)。所以我们只需要做一下几个方向
```
            res1 = matrix[lc][lc:N - lc] # we are at row-lc
            res2 = [x[N-1-lc] for x in matrix[lc+1: M -1 - lc]] # we are at col-(N-1-lc)
            res3 = matrix[M-1-lc][lc:N-lc][::-1] if M-1-lc != lc else []
            res4 = [x[lc] for x in matrix[1+lc:M-lc-1]][::-1] if N-1-lc != lc else []
```
注意，这里我使用的是水平方向到底，垂直方向相应缩短的写法。之所以不用之前说的左闭右开的方式，是因为它无法处理最后剩下单个元素未曾访问的情况，比如example 1中间的5

这里
注意，这里我使用的是水平方向到底，垂直方向相应缩短的写法。之所以不用之前说的左闭右开的方式，是因为它无法处理最后剩下单个元素未曾访问的情况，比如example 1中间的5的
注意，这里我使用的是水平方向到底，垂直方向相应缩短的写法。之所以不用之前说的左闭右开的方式，是因为它无法处理最后剩下单个元素未曾访问的情况，比如example 1中间的5


